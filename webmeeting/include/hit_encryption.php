<?

//////////////////////////////////////////////////////////////////////////////
//
//  hit_encrpytion.php
//
//  Contains tools for encryption/decrpytion (3DES and PKI) and 
//  encoding/decoding (SHA1)
//
//////////////////////////////////////////////////////////////////////////////
    
    
define('HIT_ERR_CANNOT_LOAD_ENCRYPTOR'     , 1500);
define('HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY', 1501);
define('HIT_ERR_ERROR_WHEN_CALLING_OPENSSL', 1502);
define('HIT_ERR_UNABLE_TO_ENCRYPT'         , 8003);
define('HIT_ERR_UNABLE_TO_DECRYPT'         , 8004);
define('HIT_WIN32_OPENSSL_PATH'            , '../helper/openssl.exe');
define('HIT_LINUX_HMTG_ENCRYPTOR_PATH'     , $_SERVER['DOCUMENT_ROOT'] . '/webmeeting/helper/jnjencryptor');


class EncryptionTool
{
    var $errorMessage;
    var $platform;
    
    function EncryptionTool(){
        // Automatic OS detection
        $this->platform = function_exists('posix_uname')? 'linux' : 'win32';
        $this->errorMessage = '';
    }
    


    //--------------------------------------------------------------------
    // NAME:    opensslEnc 
    // DESC:    Call OpenSSL to do symmetric de/encryption
    // PARAM:   output [out]
    //              Decrypted message
    //          input [in]
    //              Message to be decrypted
    //          key [in]
    //              Key to encrypt/decrypt the message
    //          options [in]
    //              arguments to be passed to OpenSSL.  Note: The first 
    //              argument must be ciphername
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function opensslEnc(&$output, $input, $key, $options = '-des3')
    {
        $inFile = tempnam('<system-default-temp>', 'enc');
        $outFile = tempnam('<system-default-temp>', 'enc');
        $keyFile = tempnam('<system-default-temp>', 'enc');
        
        // put input the content to a file
        $hFile = fopen($inFile, "w");
        fwrite($hFile, $input);
        fclose($hFile);
        
        // put the encryption key / password to a file
        $hFile = fopen($keyFile, "w");
        fwrite($hFile, $key);
        fclose($hFile);

        // Call OpenSSL to do the work
        if ($this->platform == "linux"){
            $opensslCmd = "openssl enc $options -salt -in $inFile -out $outFile -kfile $keyFile 2>&1";
        } else {
            $opensslAbsPath = '"'.realpath("../helper/openssl.exe").'"';
            $opensslCmd = "$opensslAbsPath enc $options -salt -in $inFile -out $outFile -kfile $keyFile 2>&1";
        }
        exec($opensslCmd, $response, $errCode);

        // Read output generated by OpenSSL
        // note: supposely we can use file_get_contents function,
        //       but it is only good for PHP >= 4.3.0 
        $output = '';
        $hFile = fopen($outFile, "r");
        // note: we read data using while loop instead of filesize()
        //       because filesize() fails in some system!
        //       Stat failed for <filename> (errno=2 - No such file or directory)
        while ($data = fread($hFile, 999)) {
            $output .= $data;        
        }
        fclose($hFile);


        @unlink($inFile);
        @unlink($outFile);
        @unlink($keyFile);


        if ($errCode){
            $this->errorMessage = implode(' ', $response);
            return $errCode;
        }

        if ($output == ''){
            $this->errorMessage = "Error when calling OpenSSL.  Command [$opensslCmd]  Output [$response]";
            return HIT_ERR_ERROR_WHEN_CALLING_OPENSSL;
        }
        return 0;
    }



    //--------------------------------------------------------------------
    // NAME:    tripleDesDescrypt 
    // DESC:    Decrypt a message that is encrypted using Triple DES 
    // PARAM:   plainText [out]
    //              Decrypted message
    //          cipher [in]
    //              Message to be decrypted
    //          desKey [in]
    //              Key to decrypt the message
    //          base64encode [in]
    //              TRUE = cipher is encoded in Base64 (not in Hex)
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function tripleDesDecrypt(&$plainText, $cipher, $desKey, $base64encode=TRUE)
    {
        $options = '-des3 -d';
        $options .= $base64encode ? ' -a' : '';
        
        return $this->opensslEnc($plainText, $cipher, $desKey, $options);
    }
    

    //--------------------------------------------------------------------
    // NAME:    tripleDesEncrypt 
    // DESC:    Encrypt a message using Triple DES 
    // PARAM:   cipher [out]
    //              Encrypted message
    //          plainText [in]
    //              Message to be encrypted
    //          desKey [in]
    //              Key to encrypt the message
    //          base64encode [in]
    //              TRUE = cipher will be encoded in Base64 (not in Hex)
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function tripleDesEncrypt(&$cipher, $plainText, $desKey, $base64encode=TRUE)
    {
        $options = '-des3';
        $options .= $base64encode ? ' -a' : '';
        
        return $this->opensslEnc($cipher, $plainText, $desKey, $options);
    }
    


    //--------------------------------------------------------------------
    // NAME:    pkeEncrypt 
    // DESC:    Encrypt a message using Public Key Encryption (PKE)
    // PARAM:   cipher [out]
    //              Encrypted message.  Message will be in the following format:
    //              <siteId>|<encrypted session key>|<encrypted content>
    //          plainText [in]
    //              Message to be encrypted
    //          privateKeyPath [in]
    //              Path of the (sender's) private key file
    //          publicKeyPath [in]
    //              Path of the (receipent's) public key file
    //          siteId [in]
    //              ID of the sender; this value is used by the receiver to 
    //              determine which public key it should use to decrypt the 
    //              messages; usually SiteID should be the file name of the 
    //              public key.
    //          passPhrase [in]
    //              password for opening the private key
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function pkeEncrypt(&$cipher, $plainText, $privateKeyPath, $publicKeyPath, $siteId, $passPhrase)
    {
        $originalSetting = ini_set('track_errors', 1);
        $cipher = '';
        $errCode = 0;

        $privateKeyAbsPath = realpath($privateKeyPath);
        $publicKeyAbsPath = realpath($publicKeyPath);

        do {
            //------------------------------------------------------
            // On Linux platform, we need to call a command-line program to do the encryption
            if ($this->platform == "linux"){

                $encryptorAbsPath = realpath(HIT_LINUX_HMTG_ENCRYPTOR_PATH);

                // remove Return characters in the content; encryptor only supports one line input
                $oneLineInput = preg_replace("/\r|\n/", '', $plainText);

                // Put encryption command, settings (public/private key location), and data into an ASCII instruction file
                $cmd = "encrypt,$privateKeyAbsPath,$passPhrase,$publicKeyAbsPath,$siteId,$oneLineInput";
                $errorFile = tempnam("<system-temp-dir>", 'err');
                $instructionFile = tempnam("<system-temp-dir>", 'enc');
                $hFile = fopen($instructionFile, "w");
                fwrite($hFile, $cmd);
                fclose($hFile);

                // Give the instruction file to encryptor
                $rtn = exec("\"$encryptorAbsPath\" 2>$errorFile <$instructionFile", $response, $errCode);
                $hFile = fopen($errorFile, "r");
                //marked by jeff
                //$errMsg = fread($hFile, filesize($errorFile));
                fclose($hFile);
                    
                unlink($instructionFile);
                unlink($errorFile);

                // Parse the output from encryptor
                $cipher = trim(implode(" ", $response));

                // Check for error
                if (!$cipher || $errMsg){

                    if (! file_exists($encryptorAbsPath)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                        $this->errorMessage = 
                            "Unable to locate jnjencryptor at [".HIT_LINUX_HMTG_ENCRYPTOR_PATH."] ".
                            "(Code:$errCode)";
                        break;
                    }
                    
                    if (! is_executable($encryptorAbsPath)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                        $this->errorMessage = 
                            "Unable to execute jnjencryptor at [$encryptorAbsPath] -- ".
                            "[$errMsg]  Use 'chmod guo+rx' to change permission mode. ".
                            "(Code:$errCode)";
                        break;
                    }
                    
                    if (! is_readable($privateKeyAbsPath) || ! is_readable($publicKeyAbsPath)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY;
                        $this->errorMessage = 
                            "Unable to load encryption keys -- [$errMsg] ".
                            "Private key: [$privateKeyPath] ".
                            "Public key: [$publicKeyPath] ".
                            "(Code:$errCode)";
                        break;
                    }

                    $errCode = HIT_ERR_UNABLE_TO_ENCRYPT;
                    $this->errorMessage = "Unable to encrypt data. [$errMsg] (Code:$errCode)";
                    break;
                }
               
                $errCode = 0;
                break;
            }

            //------------------------------------------------------
            // On Windows platform, we call COM to do the encryption

            // Make sure the COM component is installed
            $jnjCom = NULL;
            $jnjCom = @ new COM("Hmtg.JnjEncryptor", NULL, CP_UTF8);
            if (is_null($jnjCom)){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                $this->errorMessage = 
                    "Unable to load Hmtg.JnjEnecryptor COM object -- [$errMsg] ".
                    "Use regsvr32 to register the COM object. (Code:$errCode)";
                break;
            }

            // Tell COM about the location of pulic/private keys
            if (is_null(@ $jnjCom->LoadKeys($privateKeyAbsPath, $passPhrase, $publicKeyAbsPath))){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY;
                $this->errorMessage = 
                    "Unable to load encryption keys -- [$errMsg] ".
                    "Private key: [$privateKeyPath] ".
                    "Public key: [$publicKeyPath] ".
                    "(Code:$errCode)";
                break;
            }

            // Perform the encryption
            $cipher = @ $jnjCom->Encrypt($plainText, $siteId);
            if (! $cipher ){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_UNABLE_TO_ENCRYPT;
                $this->errorMessage = "Unable to encrypt data -- [$errMsg] (Code:$errCode)";
                break;
            }
            
            unset($jnjCom);
        } while (false);
        
        ini_set('track_errors', $originalSetting);
        return $errCode;
    }




    //--------------------------------------------------------------------
    // NAME:    pkeDecrypt 
    // DESC:    Decrypt a message using Public Key Encryption (PKE)
    // PARAM:   plainText [out]
    //              Decrypted message
    //          cipher [in]
    //              Message to be decrypted.  Message must be in the 
    //              following format:
    //              <siteId>|<encrypted session key>|<encrypted content>
    //          privateKeyPath [in]
    //              Path of the (receipent's) private key file
    //          publicKeyPath [in]
    //              Path of the (sender's) public key file
    //          passPhrase [in]
    //              password for opening the private key
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function pkeDecrypt(&$plainText, $cipher, $privateKeyPath, $publicKeyPath, $passPhrase)
    {
        // Tell PHP to save error message into variable $php_errormsg 
        $originalSetting = ini_set('track_errors', 1);
        
        $plainText = '';
        $errCode = 0;

        $privateKeyAbsPath = realpath($privateKeyPath);
        $publicKeyAbsPath = realpath($publicKeyPath);

        do {
            //------------------------------------------------------
            // On Linux platform, we need to call a command-line program to do the decryption
            if ($this->platform == "linux"){

                $encryptorAbsPath = realpath(HIT_LINUX_HMTG_ENCRYPTOR_PATH);

                // remove Return characters in the content; decryptor only supports one line input
                $oneLineInput = preg_replace("/\r|\n/", '', $cipher);

                // Put decryption command, settings (public/private key location), and data into an ASCII instruction file
                $cmd = "decrypt,$privateKeyAbsPath,$passPhrase,$publicKeyAbsPath,$oneLineInput";
                $errorFile = tempnam("<system-temp-dir>", 'err');
                $instructionFile = tempnam("<system-temp-dir>", 'enc');
                $hFile = fopen($instructionFile, "w");
                fwrite($hFile, $cmd);
                fclose($hFile);
                
                // Give the instruction file to decryptor
                $rtn = exec("\"$encryptorAbsPath\" 2>$errorFile <$instructionFile", $response, $errCode);

                $hFile = fopen($errorFile, "r");
                $errMsg = fread($hFile, filesize($errorFile));
                fclose($hFile);
                    
                unlink($instructionFile);
                unlink($errorFile);

                // Parse the output from encryptor
                $plainText = trim(implode(" ", $response));

                // Check for error
                if (!$plainText || $errMsg){

                    if (! file_exists($encryptorAbsPath)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                        $this->errorMessage = 
                            "Unable to locate jnjencryptor at [".HIT_LINUX_HMTG_ENCRYPTOR_PATH."] ".
                            "(Code:$errCode)";
                        break;
                    }
                    
                    if (! is_executable($encryptorAbsPath)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                        $this->errorMessage = 
                            "Unable to execute jnjencryptor at [$encryptorAbsPath] -- ".
                            "[$errMsg]  Use 'chmod guo+rx' to change permission mode. ".
                            "(Code:$errCode)";
                        break;
                    }
                    
                    if (! is_readable($privateKeyAbsPath) || ! is_readable($publicKeyAbsPath)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY;
                        $this->errorMessage = 
                            "Unable to load encryption keys -- [$errMsg] ".
                            "Private key: [$privateKeyPath] ".
                            "Public key: [$publicKeyPath] ".
                            "(Code:$errCode)";
                        break;
                    }

                    $errCode = HIT_ERR_UNABLE_TO_DECRYPT;
                    $this->errorMessage = "Unable to decrypt data -- [$errMsg] (Code:$errCode)";
                    break;
                }
               
                $errCode = 0;
                break;
            }

            //------------------------------------------------------
            // On Windows platform, we call COM to do the decryption

            // Make sure the COM component is installed
            $jnjCom = NULL;
            $jnjCom = @ new COM("Hmtg.JnjEncryptor", NULL, CP_UTF8);
            if (is_null($jnjCom)){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                $this->errorMessage = 
                    "Unable to load Hmtg.JnjEnecryptor COM object -- [$errMsg] ".
                    "Use regsvr32 to register the COM object. (Code:$errCode)";
                break;
            }

            // Tell COM about the location of pulic/private keys
            if (is_null(@ $jnjCom->LoadKeys($privateKeyAbsPath, $passPhrase, $publicKeyAbsPath))){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY;
                $this->errorMessage = 
                    "Unable to load encryption keys -- [$errMsg] ".
                    "Private key: [$privateKeyPath] ".
                    "Public key: [$publicKeyPath] ".
                    "(Code:$errCode)";
                break;
            }

            // Perform the decryption
            $plainText = @ $jnjCom->Decrypt($cipher);
            if (! $plainText ){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_UNABLE_TO_DECRYPT;
                $this->errorMessage = "Unable to decrypt data -- [$errMsg] (Code:$errCode)";
                break;
            }
            
            unset($jnjCom);
        } while (false);
        
        ini_set('track_errors', $originalSetting);
        return $errCode;
    }



    //---------------------------------------------------------------------------
    // NAME:    getBase64Sha1
    // DESC:    Calculate the sha1 hash of a string in Base64 encoding
    // PARAM:   $hash [out]
    //            Hash in base64 encoding
    //          plainText [in]
    //            String to be hashed
    // RETURN:  0 if operation is success
    //---------------------------------------------------------------------------
    function getBase64Sha1(&$hash, $plainText){

        if ($plainText == NULL || $plainText === ''){
            $hash = '';
            return 0;
        }

        $hexSha1 = sha1($plainText);
        $binarySha1 = '';
        for ($i=0; $i<strlen($hexSha1); $i=$i+2){
            $binarySha1 .= chr(hexdec(substr($hexSha1,$i,2)));
        }

        $hash = base64_encode($binarySha1);
        return 0;
    }  
}

?>
